#labels Phase-Design,Phase-Implementation
=Milestone 4: Requirements and preliminary design=
  * Mike Hoffert - mlh374
  * Syed Ahsan Rizvi - sar457
  * Hattan Alsharif - haa775
  * Da Tao - dat293
  * Michael Butler - mdb815

==1 - Summary use cases==
===Change backup folder===
====Level====
Summary

====Actors====
User

====Goal====
To allow the user to select a new location to store their backed up files.

====Activities====
The user chooses an option from a menu in the front end GUI. This opens a prompt to select a new directory location for the backup directory. Choosing a new location asks for confirmation. If the user confirms the action, the file that specifies the location of the backup directory is changed. The contents of the previous backup folder are then copied to the new location. The user is then prompted if they wish to delete the old backup location.

====Quality====
This aspect of the program is of very low priority, due to the fact that the program does not require this functionality to work. However, due to the fact that bugs here could cause a loss of all backed up data, it is a requirement that this functionality be stable. Therefore, it will likely be put off until last, and implemented only if time allows.

====Version====
11 October 2013

===First run===
====Level====
Summary

====Actors====
User

====Goal====
To setup the live and backup directories on the first time the program is run

====Activities====
The program determines if it is the first run by checking for the existence of the file which specifies the backup directory. If this file is not found or the backup directory is invalid, it is considered to be the first run. A GUI wizard is shown, and the user is asked if they wish to specify a new backup or if they wish to import an old backup. To create a new backup, the user is prompted for paths for a live and backup directory (which cannot be children of one or the other). To import an old backup, the user is prompted to provide a path to the backup folder (which contains a database file). If the user enters invalid paths, they will be prompted to enter a new one. The wizard also allows the user to go back and change previously made choices. On the final screen of the wizard, the program initializes the backup and live directories and creates the database connection.

====Quality====
This aspect of the program is top priority, as it is mandatory for the program to be used at all. Therefore, it must be completely stable and well designed. In fact, this portion of the program is already complete in our prototype, as will be demonstrated in section 9.

====Version====
11 October 2013

===Create file===
====Level====
Summary

====Actors====
System

====Goal====
Add the file created by user to the system and backup it.

====Activities====
The system receives a file created notice from the watcher module. 

  a)a file with the same name and the same location has been existed in the system
      Since there has been the "same" file existing, the system will first add a record, stating this special situation. The system will keep the previous backups, but do not make a diff file in this case. The system will copy the newly created file into the backup folder. 
  b)no file with the same name and the same location has been existed in the system
      The system just simply copies the file into the backup folder. Then a new record will be added in database stating a new file added.

====Quality====
This is a main use case in the system and must work to a very high standard.

====Version====
13 October 2013

===Rename file===
====Level====
Summary

====Actors====
System

====Goal====
Reflect that user renamed a file.

====Activities====
The system receives a file renamed notice from the watcher module. First the system will add a record to the database of this; then the system will rename all backups and records of this file.

====Quality====
This is a main use case in the system and must work to a very high standard.

====Version====
13 October 2013


===Rename folder===
====Level====
Summary
====Actors====
user
====Goal====
To rename a backup folder to a new name.
====Activities====
The user specifies whatever folder he/she wants to rename it and then give it a new name. The system checks if  the new name is already exist, then the user will be notified to choose another one, otherwise the folder name will be changed.

====Quality====
This is a main use case in the system and must work to a very high standard.
====Version====
14 October 2013


===View Revision===
====Level=====
Summary
====Actors====
User
====Goal====
To show or display a selected revision of a file.
====Activities====
The user select a whatever file he/she wants to view a specific revision for that file. With a selected file, the user is presented a list of revisions and options, which include view revision.
====Quality====
This is a main use case in the system and must work to a very high standard.
====Version====
14 October 2013

----
  * 10 of these in total
  * Da: Create file; Rename file -- done
  * Ahsen: Delete file; Create folder
  * Hattan: Rename folder; View revision -- done
  * Michael: Revert file to revision; Change live folder
  * Mike: Change backup folder; First run -- done
  * See RUP_Inception slide 18 for an example
----

==2 - Fully dressed use cases==
===First run===
====Scope====
Program is run for the first time

====Level====
User goal

====Primary Actor====
User

====Stakeholders and interests====
User: Setup the program with the directories it will act on.

====Preconditions====
It is the program's first run or the program cannot startup normally.

====Success Guarantee====
The backup and live directories are configured to valid paths.

====Main Success scenario====
  * Program determines that it is the first run because the file pointing to the backup location is missing, or the backup location is otherwise invalid (non-existent folder or missing necessary database file inside this folder).
  * A GUI wizard is displayed, with buttons for navigating and exiting the wizard.
  * The wizard prompts the user as to whether they wish to create a new backup or import an existing backup.
    * If a new backup is chosen, the user is prompted to provide paths for both the live and backup directories (via file choosers).
    * If the user chooses to import an existing backup, they are prompted to provide a path to this backup directory.
  * The wizard finalizes, telling the user that setup was completed.
  * The program establishes a connection with the database, setting it up in the specified backup directory by creating the file that points to the backup directory.

====Extensions====
  * The user cannot specify live and backup directories that are children or parents of each other.
    * This prevents infinite recursion. If the backup folder was inside the live directory, every backup would be identified as a change to the live directory (and thus need to be backed up as well). If the live directory was inside the backup directory, then we run the risk of backed up files overwriting files in the live directory.
    * The program will issue an error dialog if this occurs, and will not allow the user to continue until they specify valid directories.
  * When importing an existing backup, the chosen directory must contain a database file which indicates that the directory has been used for backup before.
    * This file contains the path of the live directory, which is necessary for the program to import an existing backup.
    * The program will issue an error dialog if this occurs, and will not allow the user to continue until they specify a valid directory.
  * If the user closes the dialog window, it will do nothing unless they are on the final panel of the wizard, which indicates a success.

====Special Requirements====
  * The program directory and the chosen live and backup directories _must_ have write access.

====Technology and Data Variations List====
  * The program flow changes based on whether the user chose to import an existing backup or start a new one. If they chose to import an existing backup, the live directory is set when the program initializes the database. If they started a new backup, the wizard sets the live directory.

====Frequency of Occurrence====
  * Exactly once when the program starts for the first time
  * May also occur if an error is encountered when the program starts up (such as if the backup directory is invalid)

===Create file===
====Scope====
  * FBMS

====Level====
  * System goal

====Primary Actor====
  * User

====Stakeholders and interests====
  * User: Want this new created file is automatically backuped.

====Preconditions====
  * The Watcher module is running normally.
  * There is enough space in backup folder.
  * System has read access to the newly created file.
  * System has write access to backup folder.

====Success Guarantee====
  * The newly created file is backuped.
  * Records are added in database.
  * The history of this file is accessible from GUI.


====Main Success scenario====
  * Program determines whether a file with the same name and location has been existed in the system.
    * If it exists, system adds a special record indicating a file with the same name and location is created. Then the system renames the previous file backup, to prevent  overwriting.
    * If not, system goes to next step straightly.
  * System copies the newly created file into backup folder.
  * System establishes a connection with the database, inserting a new record into the database.

====Extensions====
  * The file will be locked when being copied to backup folder.

====Special Requirements====
  * Privilege is possible required.

====Technology and Data Variations List====
  * The program flow changes based on whether a file with the same name and location has been existed in the system. If it exists, system will do additional steps to ensure no overwriting occurs. If not, system will do it in regular way.

====Frequency of Occurrence====
  * Every time a new file is created in live folder


===Rename Folder===

====Scope====
FBMS
====Level====
User goal
====Primary Actor====
User
====Stakeholders and interests====
User: Want this folder to be renamed.
====Preconditions====
The Watcher module is running normally. There is no similar folder name. 
====Success Guarantee====
The folder has renamed to a new name. The new folder history is added in database. The history of this folder is accessible from GUI.
====Main Success scenario====
•	The user wants to rename a specific folder.
•	Program determines whether the folder’s name has been changed in the system or the new name exists.
◦	If it is exist, ask the user for another name
◦	If not, system goes to next step straightly.
====Extensions====
•	The folder will be renamed, and it’s files will remain with no changes.
====Special Requirements====
•	No same folder’s name is exist.
====Technology and Data Variations List====
•	The system determines whether the folder with the new name and location has been existed in the system or not to ensure no overwriting occurs.
====Frequency of Occurrence====
Each time a folder’s name is changed


----
  * 5 of these in total
  * Choose one of the summary cases you used in (1)
  * See larman-ch6-applying-evolutionary-use-cases.pdf in Dropbox for details and an example
----

==3 - Supplementary specification==
  * See RUP_Inception slides 33-44 for details and examples
  * Not concrete; feel free to change your assigned concept for something else if you feel that would be easier
  
===Interfaces===
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

  * Done by Ahsen
  * Describe things like the GUI, choices we made, why, etc
  * How errors are presented to use
  * Detailed explanation of GUI layout and functionality

===Vision===
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

  * Done by Michael
  * Why we chose this project, overall goals
  * User benefits, etc

===Third party components===
The project uses third party components for several areas, allowing the project to be completed in a reasonable span of time, as well as assisting in functionality beyond our current skills. Currently, we use:

  * *JNotify*: This library is used to detect changes in the live directory. It is capable of running event handlers when file changes occur. This allows us to efficiently find the changes in the directory. JNotify binds with the operating system (in which it supports all the major operating systems), allowing it to function similar to an interrupt-style listener. The program will then use a polling system to perform file operations on changes that occurred since the last poll. This makes spotting changes fast while minimizing file operations (which often occur in multiples even if the operation appeared atomic to the user).
  * *Log4j*: The well known logging library is used to making logging efficient and configurable. Most importantly, it allows us to set levels to our logging. When the logging is set to DEBUG, the logging system is very verbose. This is useful when we need to know exactly what the program is doing, but for general usage, this slows the program down and floods the logs with irrelevant information. Normally, the user will have the logging set to either WARN or ERROR, which will limit the logging to things that are of actual use to the user.
  * *Java-diff-utils*: This library is used to generate diff files, which is what our revisioning system is based on. The library is also used to apply the files, restoring the originals. To restore files several revisions old, the diff files are chained together, restoring revisions until we get to the one we want.
  * *SQLite*: We use the SQLite JDBC driver to allow our databases to be well organized into an efficient, minimal file.

These components integrate with our program and were chosen with efficiency in mind.
  
===Supportability===

====OS Compatibility====

  * Different OS organizes files in different ways. For Unix-like OS (Mac OS X and Linux), files and folders are in a single tree root; for Windows, first there are many roots(drives), then the roots have their own trees.

  * Since that, it is necessary to declare the OS type in configuration.

  * Besides, the separator differs. Unix use "/", while Windows use "\". Fortunately, Java provides a method to retrieve the separator used. It should not be a problem.

====Network Drives====

  * This feature will be implemented as a plug-in.

====Configuration====

  * The configuration will be stored as plain text, in the folder of program. 
  * The locations of live and backup folder could be changed. 
    * A change in live folder will cause a factory reset.
  * Importing is easy. Just select the previous backup folder, and the system will take care of the rest.
    * A backup of database will be stored in backup folder for a backup. 
  
===Reliability===
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

  * Done by Hattan
  * Handling of errors
  * Logging
  * Actions that have reliability issues, like copying files
  * Performance (file scanner, control does file ops at intervals, etc)

==4 - Use Case Diagram==
  * To be decided

==5 - Domain Model==
  * To be decided
  * UML class diagram

==6 - Glossary==
  * *Live directory*: The directory that the program monitors for changes. In other words, the directory that is being backed up.
  * *Backup directory*: The directory where the backed up files and revisions from the live directory are placed.
  * *Revision*: A snapshot of a file at a given time.
  * *Diff*: Data that details what changed from one revision of a file to another. Also called a _patch_.
  * *Revision database*: The database where revisions are stored as diff files.
  * *Front end*: The visible portions of the program, including the main GUI window, the toolbar icon, and dialogs.
  * *Watcher*: The program component that watches the live directory for changes. It operates concurrently from the rest of the program.
  * *Control*: The heart of the program that performs setup and acts on the files that the watcher flags as "changed".
  * *File operations*: Operations that change a file's content, name, or location. This includes operations such as file creation, renaming, moving, or deletion.
  * *Error alerts*: GUI dialogs that alert the user to an error. They are split into two branches:
     * *Fatal alerts*: Obtrusive dialogs that indicate that the program cannot proceed.
     * *Non-fatal alerts*: Non-obtrusive dialogs that appear in the bottom right corner of the screen and automatically disappear after some time. These indicate something has gone wrong and cannot be recovered, but do not halt the progress of the program. For example, a file that cannot be backed up (perhaps due to permission issues).

==7 - System Sequence Diagram==
  * One by each group member
  * Use one of the use cases you used in (1)
  * UML Sequence diagram
  * Need to decide on program to use to create UML model, so TBD(?)

==8 - Operation Contracts==
===Change backup folder===
====Cross references====
  * Copy file operation
  * Delete file operation
  * Set configuration database operation

====Pre-conditions====
  * None

====Post-conditions====
  * The backup directory is changed, both in the program and in the file that stores the backup directory's location
  * If the user agreed to it, the contents of the previous backup directory were copied to the new directory
  * If the user agreed to it, the old backup directory is deleted

===First run===
====Cross references====
  * Initialize database operation
  * Set configuration database operation

====Pre-conditions====
  * None

====Post-conditions====
  * The live and backup directory locations are set
  * The database file is created if this is a new backup

===Create File===
====Cross references====
  * Insert new record into database
  * Rename file if necessary

====Pre-conditions====
  * Backup folder exists and has enough space.

====Post-conditions====
  * The newly created file is backed.
    * Previous backup will be renamed if the backup has the same name and locations as the newly created one.

===Rename File===
====Cross references====
  * Insert a rename record into database
  * Change file name in previous records
  * Change previous backups' name.

====Pre-conditions====
  * A file is renamed.
  * Backup folder exists.
  * Backups of the file renamed exist.
  * Records of the file exists in database.

====Post-conditions====
  * A file rename record is inserted into database.
  * All file names of the records of the file renamed are changed.
  * All backups' name of the records of the file renamed are changed.

===Rename folder===
====Cross references====
•	Copy files operation
•	Delete files operation
•	Change backup folder
====Pre-conditions====
•	None
====Post-conditions====
•	The folder name is changed.
•	The files in the folder remain the same.

===View revision===
====Cross references====
•	Display the file history
•	Revert the revision
====Pre-conditions====
•	File should be selected.
====Post-conditions====
•	The revision of a selected file is shown using GUI.



----
  * 10 of these in total
  * Each group member makes 2 using the use cases they used in (1)
  * See RUP_Elaboration slides 44-50 for details and an example
----
  
==9 - Implementation==
Our prototype includes the first run use case as well as unused implementations of several other functions, which don't yet hook into the program. The program will startup, run the first run wizard, and then sit in the background with the file listener monitoring files. It won't yet do anything with the changed files, however.

So far, Mike has setup the skeleton implementation, the Watcher class, the init function of the DbManager class, the first run wizard, the getFolderContents function of the Data class, the Error class, and the startup methods of the Control class. Michael has done the getConfig and setConfig classes of the DbManager class. Da has done the delete and filesize methods of the FileOp class.

To build the project, extract the contents of the project's zip file. In Eclipse, choose File > Import and under General, choose to import an existing project into the workspace, choosing the directory you extracted the project's files into (should contain a `.project` file). From here, Eclipse can run the program. The project currently requires Eclipse Juno and JUnit 4. Final versions of the project will be setup for distribution so that Eclipse is not needed.

---

  * Details of prototype
  * Purpose, who did what, etc
  * Skeleton implementation of other parts. Everyone needs to have implemented at least _some_ code by submission time
  * Details of usage, compiling, etc
  * Mike will put this together, but implementation of at least something by everyone is needed
  * Focus on FileOp stuff and Control handling the lists of changed files; FileHistory and DbManager can wait
  
---

==10 - Project Plan==
Implementation has found the need for new methods and approaches, such as how we now store the revisions database in the backup folder instead of in the program folder. This example created a bit more work, but keeps the backup all in one place. Similarly, the first run wizard now allows the user to import an existing backup.

The assigned tasks and time estimates are otherwise unchanged from milestone 3 (with the done functionality removed from these lists):
<pre>
                                 Estimated time req
MIKE:                                 (in hours)
    Control.displayRevision()             3
    Control.displayRevisionChanges()      3
    Control.revertRevision()              4
    DbManager.getRevisionData()           3
                                         ---
                                 Total:  13

MICHAEL:
    Control.handleCreatedFiles()          4
    Control.handleModifiedFiles()         4
    Control.handleRenamedFiles()          4
    Control.HandleDeletedFiles()          4
    DbManager.renameFile()                3
                                         ---
                                 Total:  18

DA:
    FileHistory.getRevision()             3
    FileHistory.obtainRevision()          6
    FileHistory.storeRevision()           3
    FileOp.rename()                       2
    FileOp.copy() (both)                  4
    FileOp.fileValid()                    3
                                         ---
                                 Total:  21


HATTAN:
    Control.restoreBackup()               4
    FileOp.createDiff()                   5
    FileOp.applyDiff()                    5
    FileOp.fileToList()                   3
    FileOp.isFolder()                     3
    Data.getRevisionInfo()                3
    DbManager.insertRevision()            3
                                         ---
                                 Total:  26


SYED:
    FrontEnd.*                           20
    FileHistory.renameRevision()          3
                                         ---
                                 Total:  23

--------------------------------------------
                           Grand total: 126
</pre>

The hours that have been spent so far on the project are:
<pre>
	Mike:
		- Planning and documentation:   5 hours
		- Work on previous milestones:  5 hours
		- Utility demo:                 8 hours
		- Skeleton implemention and
		  PoD classes:                  2 hours
		- Watcher class:                1 hour
		- DbManager.init():             3 hours
		- FirstRunWizard class:         6 hours
		- Data.getFolderContents():     2 hours
		- Various Control code related
		  to startup:                   5 hours
		- JUnit testing code:           2 hours
		- Errors class:                 3 hours
		                        Total: 42 hours
	Da:
		- Rough design of modules:      1 hour
		- Rough design of functions:    1 hour
		- Work on previous milestones:  4 hours
		- Programming(so far):          3 hours
                                       Total:  9 hours
	Ahsen:
		-
	Hattan:
		-
	Michael:
		-
 * Note: Times are estimates. Note included is research time, time used
   by meetings, class time, etc.
</pre>

---
  * *Need hours you've spent on project so far, broken up into components*. Please post this here. *<---  <---*
  * Run into any need for changes? Areas where you may need more or less time? Post it here.
  * Mike will put this part together just before submission
---
  
=FINISH 1, 2, 3, 8, AND 10 BEFORE THE END OF 15 OCTOBER=
  * 4, 5, 7 require UML modelling tools, so will have to be discussed. Anyone have ideas of programs to use? If possible, we should try and use the same program for consistency
  * 9 and rest of 10 will be completed shortly before submission is due. They're best put off till last minute so we can fit as much work as possible into them
  * For readability, I'll add page breaks between each numbered section in the final PDF format. I'll also try making headers more visible and adding borders